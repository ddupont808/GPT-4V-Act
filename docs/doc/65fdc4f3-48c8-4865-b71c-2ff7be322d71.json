{
    "summary": "The code customizes scrollbar styles, adds event listeners for navigation messages and URL changes using Electron's IPC API, shuffles web page elements randomly, removes labels, marks elements based on viewport position, generates clickable lists with specific properties and filters, applies random color generation, creates a floating border with visible labels, styles labels, appends and adds elements to the body, saves them in an array, and sends data via IPC.",
    "details": [
        {
            "comment": "This code defines custom CSS styles for scrollbars and adds event listeners to handle navigation messages from \"preload.js\" using Electron's IPC (Inter-Process Communication) API.",
            "location": "\"/media/root/Toshiba XG3/works/GPT-4V-Act/docs/src/preload-view.js\":0-42",
            "content": "const customCSS = `\n    ::-webkit-scrollbar {\n        width: 10px;\n    }\n    ::-webkit-scrollbar-track {\n        background: #27272a;\n    }\n    ::-webkit-scrollbar-thumb {\n        background: #888;\n        border-radius: 0.375rem;\n    }\n    ::-webkit-scrollbar-thumb:hover {\n        background: #555;\n    }\n`;\nwindow.addEventListener('DOMContentLoaded', () => {\n    const styleTag = document.createElement('style');\n    styleTag.textContent = customCSS;\n    document.head.append(styleTag);\n});\nconst { ipcRenderer } = require('electron');\n// Listen for messages from preload.js to navigate\nipcRenderer.on('navigate-webview', (event, action, payload) => {\n    switch (action) {\n        case 'goBack':\n            if (window.history.length > 1) {\n                window.history.back();\n            }\n            break;\n        case 'goForward':\n            if (window.history.length > 1) {\n                window.history.forward();\n            }\n            break;\n        case 'reload':\n            window.location.reload();\n            break;"
        },
        {
            "comment": "This code handles page URL changes and sends current URL to the background process using IPC (Inter-process Communication). It uses a MutationObserver to detect any changes in the URL.",
            "location": "\"/media/root/Toshiba XG3/works/GPT-4V-Act/docs/src/preload-view.js\":43-74",
            "content": "        case 'loadURL':\n            window.location.href = payload;\n            break;\n    }\n});\n// Send the current URL whenever it changes\nwindow.addEventListener('load', () => {\n    ipcRenderer.send('current-url', window.location.href);\n    let oldHref = document.location.href;\n    const body = document.querySelector(\"body\");\n    const observer = new MutationObserver(mutations => {\n        if (oldHref !== document.location.href) {\n            oldHref = document.location.href;\n            ipcRenderer.send('current-url', window.location.href);\n        }\n    });\n    observer.observe(body, { childList: true, subtree: true });\n});\nwindow.addEventListener('beforeunload', () => {\n    ipcRenderer.send('current-url', window.location.href);\n});\nwindow.addEventListener('popstate', () => {\n    ipcRenderer.send('current-url', window.location.href);\n});\nipcRenderer.on('randomize', (event) => {\n   // Define random x and y coordinates within the dimensions of the document\n   var x = Math.floor(Math.random() * (document.body.scrollWidth + 1));"
        },
        {
            "comment": "This code shuffles the elements of a web page by randomly scrolling to a new position and shuffling the order of children within a parent element using the shuffleString function.",
            "location": "\"/media/root/Toshiba XG3/works/GPT-4V-Act/docs/src/preload-view.js\":75-107",
            "content": "   var y = Math.floor(Math.random() * (document.body.scrollHeight + 1));\n   // Scroll to the random positions\n   window.scrollTo(x, y);\n});\nipcRenderer.on('shuffle', (event) => {\n  // Helper function to shuffle a string\n  function shuffleString(str) {\n    var arr = str.split(''); \n    var len = arr.length;\n    // While there remain elements to shuffle\u2026\n    for (var i = len - 1; i > 0; i--) {\n        // Pick a remaining element\u2026\n        var j = Math.floor(Math.random() * (i + 1));\n        // And swap it with the current element.\n        var temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    return arr.join(''); // Convert Array back to string\n  }\n  function shuffleChildren(parent) {\n    if(parent.children && parent.children.length > 0) {\n        var children = Array.from(parent.children);\n        while (children.length) {\n            // Pick a random index\n            var randomIndex = Math.floor(Math.random() * children.length);\n            // Get the child at the random index\n            var child = children.splice(randomIndex, 1)[0];"
        },
        {
            "comment": "Appends child to parent, shuffles text if child only contains text, recursively shuffles children's children.\nCalls function with body as parent node and defines random x and y coordinates within document dimensions.\nScrolls to random positions on window.\nListens for 'observer' event with state and payload, marks/unmarks page based on states 'screenshot-start' or 'screenshot-end'. \nDefines an empty array 'labels' for DOM Labeler functionality.",
            "location": "\"/media/root/Toshiba XG3/works/GPT-4V-Act/docs/src/preload-view.js\":108-145",
            "content": "            // Append the child to the parent\n            parent.appendChild(child);\n            // If child node only contains text, then shuffle the text\n            if(child.children.length === 0) {\n                child.textContent = shuffleString(child.textContent);\n            }\n            // Recursively shuffle children's children\n            shuffleChildren(child);\n        }\n    }\n  }\n  // Call the function with the body as the parent node\n  shuffleChildren(document.body);\n  // Define random x and y coordinates within the dimensions of the document\n  var x = Math.floor(Math.random() * (document.body.scrollWidth + 1));\n  var y = Math.floor(Math.random() * (document.body.scrollHeight + 1));\n  // Scroll to the random positions\n  window.scrollTo(x, y);\n});\nipcRenderer.on('observer', (event, state, payload) => {\n  switch (state) {\n      case 'screenshot-start':\n          markPage();\n          break;\n      case 'screenshot-end':\n          unmarkPage();\n          break;\n  }\n});\n// DOM Labeler\nlet labels = [];\nfunction unmarkPage() {"
        },
        {
            "comment": "This code is removing all the labels from the HTML document and then marking each element on the page based on their position relative to the viewport.",
            "location": "\"/media/root/Toshiba XG3/works/GPT-4V-Act/docs/src/preload-view.js\":146-179",
            "content": "  for(const label of labels) {\n    document.body.removeChild(label);\n  }\n  labels = [];\n}\nfunction markPage() {\n  unmarkPage();\n  var bodyRect = document.body.getBoundingClientRect();\n  var items = Array.prototype.slice.call(\n    document.querySelectorAll('*')\n  ).map(function(element) {\n    var vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);\n    var vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);\n    var rects = [...element.getClientRects()].filter(bb => {\n      var center_x = bb.left + bb.width / 2;\n      var center_y = bb.top + bb.height / 2;\n      var elAtCenter = document.elementFromPoint(center_x, center_y);\n      return elAtCenter === element || element.contains(elAtCenter) \n    }).map(bb => {\n      const rect = {\n        left: Math.max(0, bb.left),\n        top: Math.max(0, bb.top),\n        right: Math.min(vw, bb.right),\n        bottom: Math.min(vh, bb.bottom)\n      };\n      return {\n        ...rect,\n        width: rect.right - rect.left,"
        },
        {
            "comment": "This code snippet generates a list of clickable elements on the webpage and returns information about them, including their bounding rectangle, area size, and whether they are input fields, buttons, links, or other interactive elements. It also applies a filter to keep only items with an area greater than 20 pixels and removes inner clickable items. Additionally, it defines a function to generate random colors.",
            "location": "\"/media/root/Toshiba XG3/works/GPT-4V-Act/docs/src/preload-view.js\":180-209",
            "content": "        height: rect.bottom - rect.top\n      }\n    });\n    var area = rects.reduce((acc, rect) => acc + rect.width * rect.height, 0);\n    return {\n      element: element,\n      include: \n        (element.tagName === \"INPUT\" || element.tagName === \"TEXTAREA\" || element.tagName === \"SELECT\") ||\n        (element.tagName === \"BUTTON\" || element.tagName === \"A\" || (element.onclick != null) || window.getComputedStyle(element).cursor == \"pointer\") ||\n        (element.tagName === \"IFRAME\" || element.tagName === \"VIDEO\")\n      ,\n      area,\n      rects,\n      text: element.textContent.trim().replace(/\\s{2,}/g, ' ')\n    };\n  }).filter(item =>\n    item.include && (item.area >= 20)\n  );\n  // Only keep inner clickable items\n  items = items.filter(x => !items.some(y => x.element.contains(y.element) && !(x == y)))\n  // Function to generate random colors\n  function getRandomColor() {\n    var letters = '0123456789ABCDEF';\n    var color = '#';\n    for (var i = 0; i < 6; i++) {\n      color += letters[Math.floor(Math.random() * 16)];"
        },
        {
            "comment": "Generates a floating border with a visible label on top of each element for better visibility.",
            "location": "\"/media/root/Toshiba XG3/works/GPT-4V-Act/docs/src/preload-view.js\":210-236",
            "content": "    }\n    return color;\n  }\n  // Lets create a floating border on top of these elements that will always be visible\n  items.forEach(function(item, index) {\n    item.rects.forEach((bbox) => {\n      newElement = document.createElement(\"div\");\n      var borderColor = getRandomColor();\n      newElement.style.outline = `2px dashed ${borderColor}`;\n      newElement.style.position = \"fixed\";\n      newElement.style.left = bbox.left + \"px\";\n      newElement.style.top = bbox.top + \"px\";\n      newElement.style.width = bbox.width + \"px\";\n      newElement.style.height = bbox.height + \"px\";\n      newElement.style.pointerEvents = \"none\";\n      newElement.style.boxSizing = \"border-box\";\n      newElement.style.zIndex = 2147483647;\n      // newElement.style.background = `${borderColor}80`;\n      // Add floating label at the corner\n      var label = document.createElement(\"span\");\n      label.textContent = index;\n      label.style.position = \"absolute\";\n      label.style.top = \"-19px\";\n      label.style.left = \"0px\";\n      label.style.background = borderColor;"
        },
        {
            "comment": "This code sets the style of a label, appends it to an element, adds that element to the body, pushes the element into a labels array, and sends label data via IPC.",
            "location": "\"/media/root/Toshiba XG3/works/GPT-4V-Act/docs/src/preload-view.js\":237-256",
            "content": "      label.style.color = \"white\";\n      label.style.padding = \"2px 4px\";\n      label.style.fontSize = \"12px\";\n      label.style.borderRadius = \"2px\";\n      newElement.appendChild(label);\n      document.body.appendChild(newElement);\n      labels.push(newElement);\n      // item.element.setAttribute(\"-ai-label\", label.textContent);\n    });\n  })\n  ipcRenderer.send('label-data', JSON.stringify(items.map(item => {\n    return {\n        x: (item.rects[0].left + item.rects[0].right) / 2, \n        y: (item.rects[0].top + item.rects[0].bottom) / 2,\n        bboxs: item.rects.map(({left, top, width, height}) => [left, top, width, height])\n    }\n  })));\n}"
        }
    ]
}